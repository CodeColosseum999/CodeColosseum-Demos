<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<style>
  html, body { margin: 0; padding: 0; background: #000; overflow: hidden; }
  canvas { display: block; image-rendering: pixelated; }
</style>
</head>
<body>
<script>
(function() {
  // --- Parameters & Setup ---
  const params = new URLSearchParams(window.location.search);
  const safeInt = (v, min, max, def) => {
    const n = parseInt(v, 10);
    return (isNaN(n) || !isFinite(n)) ? def : Math.max(min, Math.min(max, n));
  };
  const safeFloat = (v, min, max, def) => {
    const n = parseFloat(v);
    return (isNaN(n) || !isFinite(n)) ? def : Math.max(min, Math.min(max, n));
  };

  const w = safeInt(params.get('w'), 64, 4096, 416);
  const h = safeInt(params.get('h'), 64, 4096, 416);
  const loopDuration = safeInt(params.get('loop'), 1000, 600000, 10000);
  const speed = safeFloat(params.get('speed'), 0.1, 20, 1);
  const t0 = safeFloat(params.get('t0'), 0, Number.MAX_SAFE_INTEGER, 0);
  const phase = safeFloat(params.get('phase'), 0, Number.MAX_SAFE_INTEGER, 0);

  // --- Canvas Init ---
  const canvas = document.createElement('canvas');
  const dpr = window.devicePixelRatio || 1;
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  canvas.width = Math.floor(w * dpr);
  canvas.height = Math.floor(h * dpr);
  document.body.appendChild(canvas);

  const ctx = canvas.getContext('2d');
  if (!ctx) throw new Error("Canvas 2D context not supported");

  // Disable smoothing for pixel art look
  ctx.imageSmoothingEnabled = false;

  // --- Grid / Simulation Configuration ---
  const GRID_W = 100;
  const GRID_H = 100;
  const CELL_EMPTY = 0;
  const CELL_BEDROCK = 1;
  const CELL_WOOD = 2;
  const CELL_SAND = 3;
  const CELL_WATER = 4;
  const CELL_ACID = 5;

  // Data Arrays
  // Current state
  let grid = new Uint8Array(GRID_W * GRID_H);
  // We use a small offscreen buffer for the pixel art logic
  const offCanvas = document.createElement('canvas');
  offCanvas.width = GRID_W;
  offCanvas.height = GRID_H;
  const offCtx = offCanvas.getContext('2d');
  const imgData = offCtx.createImageData(GRID_W, GRID_H);
  const buf32 = new Uint32Array(imgData.data.buffer);

  // Colors (ABGR little-endian usually: 0xAABBGGRR)
  const COL_EMPTY = 0xFF000000;
  const COL_BEDROCK = 0xFF505050; // Dark Gray
  const COL_WOOD = 0xFF1E69D2;    // Chocolate/Orange-ish (R=D2, G=69, B=1E) -> AABBGGRR
  const COL_SAND = 0xFF00D7FF;    // Gold/Yellow (R=FF, G=D7, B=00)
  const COL_WATER = 0xFFFFFF00;   // Cyan (R=00, G=FF, B=FF)
  const COL_ACID = 0xFF00FF00;    // Neon Green

  // Simulation State
  let simTimeAccumulator = 0;
  let lastLoopIndex = -1;
  let prngState = 1234;
  let frameCount = 0;

  // --- Random Number Generator ---
  // Simple Mulberry32 for deterministic seeding
  function seedPRNG(seed) {
    prngState = seed;
  }
  function random() {
    let t = prngState += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
  function randInt(max) {
    return Math.floor(random() * max);
  }

  // --- Simulation Logic ---

  function resetSimulation() {
    // Clear Grid
    grid.fill(CELL_EMPTY);
    frameCount = 0;

    // Build Map
    // 1. Bedrock bottom
    for (let x = 0; x < GRID_W; x++) {
      grid[(GRID_H - 1) * GRID_W + x] = CELL_BEDROCK;
    }

    // 2. Three Random Wood Platforms
    // Constraints: at least 1/3 width, random Y, avoid blocking top completely
    for (let i = 0; i < 3; i++) {
      let platW = 30 + randInt(30); // 30 to 60 width
      let platX = randInt(GRID_W - platW);
      let platY = 30 + randInt(50); // Y range 30..80 (0 is top)
      
      for (let px = 0; px < platW; px++) {
        let idx = platY * GRID_W + (platX + px);
        if (idx < grid.length) grid[idx] = CELL_WOOD;
      }
    }
  }

  function getIdx(x, y) {
    if (x < 0 || x >= GRID_W || y < 0 || y >= GRID_H) return -1;
    return y * GRID_W + x;
  }

  function isEmpty(idx) {
    return grid[idx] === CELL_EMPTY;
  }

  function updateGrid() {
    frameCount++;

    // --- Spawners ---
    
    // 1. Main Sand Spawner (Top Center)
    // Spawn multiple grains per frame for "FAST stream"
    for (let s = 0; s < 2; s++) {
      let sx = 50 + randInt(3) - 1; // 49, 50, 51
      let sidx = getIdx(sx, 0);
      if (grid[sidx] === CELL_EMPTY) {
        grid[sidx] = CELL_SAND;
      }
    }

    // 2. Secondary Water Spawner (Oscillating)
    // Oscillate Left <-> Right
    let oscPhase = (frameCount / 120) * Math.PI; // Adjust speed
    let wx = Math.floor(50 + Math.sin(oscPhase) * 40);
    let widx = getIdx(wx, 5); // Start slightly lower
    if (grid[widx] === CELL_EMPTY) {
      grid[widx] = CELL_WATER;
    }

    // 3. Chaos Acid (Every 60 frames)
    if (frameCount % 60 === 0) {
      // Spawn a cluster of acid
      let ax = randInt(GRID_W - 4) + 2;
      for (let i = 0; i < 5; i++) {
        let aidx = getIdx(ax + randInt(3) - 1, 0);
        if (grid[aidx] === CELL_EMPTY) grid[aidx] = CELL_ACID;
      }
    }

    // --- Cellular Automata Physics ---
    // Iterate Bottom-Up to simulate falling
    // Randomize L/R scan per row to prevent bias is ideal, 
    // but simpler: just choose random spread direction.
    
    for (let y = GRID_H - 1; y >= 0; y--) {
      // Simple scanline for stability in this loop logic
      // To reduce bias, we can alternate scan direction or shuffle x?
      // For speed, linear scan + random choice logic.
      
      // We need to iterate copies or handle movements carefully.
      // In-place update bottom-up is standard for sand but can be glitchy with liquid flow.
      // We will check if the target cell is empty.
      
      let rowOffset = y * GRID_W;
      
      // Shuffle X iteration direction occasionally?
      // Let's just do left-to-right but randomize move logic.
      for (let x = 0; x < GRID_W; x++) {
        let idx = rowOffset + x;
        let type = grid[idx];

        if (type === CELL_EMPTY || type === CELL_BEDROCK || type === CELL_WOOD) continue;

        // Logic for Falling Particles
        let belowIdx = idx + GRID_W;
        
        // Boundary check (bottom)
        if (y === GRID_H - 1) {
          // Void at bottom? OR stack? Bedrock handles stack.
          // If it's falling and hits absolute bottom (should be bedrock), nothing happens.
          continue;
        }

        // ACID LOGIC
        if (type === CELL_ACID) {
          // Acid dissolves Sand and Wood
          // Check neighbors (Down, Left, Right, Up?)
          // Main logic: Fall like liquid, but if it touches destroyable, react.
          let didReact = false;
          let candidates = [belowIdx, idx-1, idx+1];
          for (let c = 0; c < candidates.length; c++) {
            let nIdx = candidates[c];
            if (nIdx >= 0 && nIdx < grid.length) {
              let nType = grid[nIdx];
              if (nType === CELL_SAND || nType === CELL_WOOD) {
                // Destroy!
                grid[nIdx] = CELL_EMPTY; // Melt hole
                grid[idx] = CELL_EMPTY;  // Use up acid
                didReact = true;
                break;
              }
            }
          }
          if (didReact) continue;
        }

        // MOVEMENT LOGIC (Sand, Water, Acid)
        // 1. Try Down
        if (grid[belowIdx] === CELL_EMPTY) {
          grid[belowIdx] = type;
          grid[idx] = CELL_EMPTY;
        } else {
          // Blocked below. Try diagonals?
          let bl = belowIdx - 1;
          let br = belowIdx + 1;
          let canLeft = (x > 0) && (grid[bl] === CELL_EMPTY);
          let canRight = (x < GRID_W - 1) && (grid[br] === CELL_EMPTY);

          // Randomly choose preferred direction to avoid bias
          let goLeft = random() > 0.5;

          if (goLeft) {
            if (canLeft) {
              grid[bl] = type;
              grid[idx] = CELL_EMPTY;
            } else if (canRight) {
              grid[br] = type;
              grid[idx] = CELL_EMPTY;
            } else if (type === CELL_WATER || type === CELL_ACID) {
              // Liquid spread (horizontal)
              let l = idx - 1;
              let r = idx + 1;
              let spreadL = (x > 0) && (grid[l] === CELL_EMPTY);
              let spreadR = (x < GRID_W - 1) && (grid[r] === CELL_EMPTY);
              if (spreadL) {
                 grid[l] = type;
                 grid[idx] = CELL_EMPTY;
              } else if (spreadR) {
                 grid[r] = type;
                 grid[idx] = CELL_EMPTY;
              }
            }
          } else {
            // Prefer Right
            if (canRight) {
              grid[br] = type;
              grid[idx] = CELL_EMPTY;
            } else if (canLeft) {
              grid[bl] = type;
              grid[idx] = CELL_EMPTY;
            } else if (type === CELL_WATER || type === CELL_ACID) {
              // Liquid spread (horizontal)
              let l = idx - 1;
              let r = idx + 1;
              let spreadL = (x > 0) && (grid[l] === CELL_EMPTY);
              let spreadR = (x < GRID_W - 1) && (grid[r] === CELL_EMPTY);
              if (spreadR) {
                 grid[r] = type;
                 grid[idx] = CELL_EMPTY;
              } else if (spreadL) {
                 grid[l] = type;
                 grid[idx] = CELL_EMPTY;
              }
            }
          }
        }
      }
    }
  }

  function render() {
    // Fill buffer
    let ptr = 0;
    for (let i = 0; i < grid.length; i++) {
      switch (grid[i]) {
        case CELL_EMPTY: buf32[ptr++] = COL_EMPTY; break;
        case CELL_SAND: buf32[ptr++] = COL_SAND; break;
        case CELL_WATER: buf32[ptr++] = COL_WATER; break;
        case CELL_WOOD: buf32[ptr++] = COL_WOOD; break;
        case CELL_BEDROCK: buf32[ptr++] = COL_BEDROCK; break;
        case CELL_ACID: buf32[ptr++] = COL_ACID; break;
        default: buf32[ptr++] = COL_EMPTY; break;
      }
    }
    
    // Put to offscreen canvas
    offCtx.putImageData(imgData, 0, 0);

    // Draw to main canvas with scaling
    // Clear main (optional if we cover it all, but good practice)
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, w, h);
    
    // Scale and draw
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // Reset transform to pixels
    // We want to draw the 100x100 image stretched to wx h
    ctx.drawImage(offCanvas, 0, 0, GRID_W, GRID_H, 0, 0, w, h);
  }

  // --- Main Loop ---
  function loop() {
    const now = Date.now();
    // Progress Calculation
    // progress = ((now - t0 + phase) % loop) / loop
    const timeInLoop = (now - t0 + phase) % loopDuration;
    // Handle negative modulus for robustness (if t0 is future)
    const correctedTimeInLoop = timeInLoop < 0 ? timeInLoop + loopDuration : timeInLoop;
    
    // Calculate loop index to detect reset
    // loopIndex increases by 1 every loopDuration
    const loopIndex = Math.floor((now - t0 + phase) / loopDuration);

    if (loopIndex !== lastLoopIndex) {
      // Loop Boundary -> Reset
      seedPRNG(loopIndex ^ 12345); // Seed with loop index for variation or consistency? 
      // Requirement: "reset/reseed on the loop boundary". 
      // To keep it deterministic per loop cycle index (so it repeats if we rewind), 
      // we seed based on loopIndex. BUT, if we want strict 10s loop video, 
      // every loop should look the SAME.
      // Usually "clean loop" means the video loops perfectly.
      // If I change the seed every time, the video won't loop perfectly at the end of 10s.
      // To make a perfect GIF, the start state at t=0 must be deterministic.
      // So I should ALWAYS seed with the SAME constant at the start of the loop.
      seedPRNG(42); 
      resetSimulation();
      simTimeAccumulator = 0;
      lastLoopIndex = loopIndex;
    }

    // Simulation Time Management
    // We update simulation in fixed steps (e.g., 60hz)
    // accumulatedTime += delta * speed
    // Limit max steps to prevent spiral of death
    
    // Calculate delta. For smooth animation, we can just use 16ms target.
    // Ideally, we track real delta.
    // However, for deterministic replay driven by 'progress', we might want to derive frame from progress?
    // But typical 'update' loops are time-delta based.
    // Let's use a standard delta time accumulator.
    
    if (!window.lastTime) window.lastTime = now;
    let dt = now - window.lastTime;
    window.lastTime = now;
    
    // Cap dt for safety (e.g. tab backgrounding)
    if (dt > 100) dt = 100;

    simTimeAccumulator += dt * speed;
    const stepMs = 1000 / 60; // 60hz physics

    // Run physics steps
    let steps = 0;
    while (simTimeAccumulator >= stepMs && steps < 10) { // Max 10 steps per frame
      updateGrid();
      simTimeAccumulator -= stepMs;
      steps++;
    }

    render();
    requestAnimationFrame(loop);
  }

  // Start
  requestAnimationFrame(loop);

})();
</script>


<!-- CodeColosseum Watermark v1 -->
<div data-cc-watermark="1" data-cc-id="2026-01-26_falling_sand/gemini.html" style="position:fixed;bottom:10px;right:10px;opacity:0.55;font-size:12px;line-height:1.2;color:#b0b0b0;z-index:999999;pointer-events:none;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;mix-blend-mode:screen;user-select:none;">
  Generated for Code Colosseum &bull; 2026-01-26_falling_sand/gemini.html &bull; d95e36e
</div>
<script data-cc-watermark-script="1">
  console.log("%cSTOP!%c This code was generated for Code Colosseum.", "font-size:20px;color:#ff3b3b;font-weight:800;", "font-size:14px;color:#ddd;font-weight:600;");
</script>

</body>
</html>